duplicated_genes <- gene_ids[duplicated(gene_ids)]
if(length(duplicated_genes) > 0) {
print(paste("有重复的基因 ID：", paste(duplicated_genes, collapse=", ")))
}
# 去除重复基因 ID，保留第一个匹配的基因
converted_genes <- mapIds(EnsDb.Hsapiens.v86,
keys = gene_ids,
column = "ENTREZID",
keytype = "GENEID",
multiVals = "first")
# 去除 NA 值并确保行名唯一
unique_genes <- !duplicated(converted_genes)
# 去除 NA 值并确保行名唯一
unique_genes <- !duplicated(converted_genes)
rt <- rt[unique_genes, ]  # 保留唯一基因行
# 更新基因表达数据的行名为 ENTREZID
rownames(rt) <- converted_genes[gene_ids][unique_genes]
# 获取有效的 ENTREZID（去除 NA 值）
valid_genes <- !is.na(converted_genes)
# 过滤掉没有 ENTREZID 的基因
rt <- rt[valid_genes, ]
# 只使用有效的 ENTREZID 来更新行名
rownames(rt) <- converted_genes[valid_genes]
# 检查是否有重复的 ENTREZID
duplicated_genes <- duplicated(converted_genes_valid)
# 获取有效的 ENTREZID（去除 NA 值）
valid_genes <- !is.na(converted_genes)
converted_genes_valid <- converted_genes[valid_genes]
rt_valid <- rt[valid_genes, ]
# 检查是否有重复的 ENTREZID
duplicated_genes <- duplicated(converted_genes_valid)
if (any(duplicated_genes)) {
print("存在重复的 ENTREZID，正在合并这些基因的表达数据...")
# 合并重复基因，计算其均值
rt_valid <- cbind(converted_genes_valid, rt_valid)
rt_combined <- rt_valid %>%
group_by(converted_genes_valid) %>%
summarise(across(everything(), mean, na.rm=TRUE))
# 更新行名为 ENTREZID
rownames(rt_combined) <- rt_combined$converted_genes_valid
rt_combined <- rt_combined[, -1]  # 删除合并后的基因列
# 更新数据
rt <- rt_combined
} else {
# 没有重复的 ENTREZID，直接更新行名
rownames(rt) <- converted_genes_valid
}
# 查看合并后的数据
head(rt)
# 只使用有效的 ENTREZID 来更新行名
rownames(rt) <- converted_genes[valid_genes]
# 加载必要的 R 包
library(limma)
library(clusterProfiler)
library(enrichplot)
library(ggplot2)
library(tidyverse)
library(EnsDb.Hsapiens.v86)
library(org.Hs.eg.db)
# 读取 RNAseq 表达数据（行是基因，列是样本）
rt <- read.table("RNAseq_data.txt", header=T, sep="\t", check.names=F, row.names=1)
# 获取基因名（ENSEMBL ID）
gene_ids <- rownames(rt)
# 去重：如果有重复的 ENSEMBL ID，仅保留第一个
rt <- rt[!duplicated(gene_ids), ]
# 使用 EnsDb.Hsapiens.v86 将 ENSEMBL ID 转换为 ENTREZID
converted_genes <- mapIds(
EnsDb.Hsapiens.v86,
keys = gene_ids,
column = "ENTREZID",
keytype = "GENEID",
multiVals = "first"
)
# 仅保留有 ENTREZID 的行
valid_genes <- !is.na(converted_genes)
rt <- rt[valid_genes, ]
converted_genes <- converted_genes[valid_genes]
# **检查是否有重复 ENTREZID**
if (any(duplicated(converted_genes))) {
print("存在重复 ENTREZID，正在合并这些基因的表达数据...")
# 绑定 ENTREZID 并计算均值
rt <- cbind(ENTREZID = converted_genes, rt)
rt <- rt %>%
group_by(ENTREZID) %>%
summarise(across(everything(), mean, na.rm=TRUE))
# 设置 ENTREZID 作为行名并删除该列
rownames(rt) <- rt$ENTREZID
rt <- rt[, -1]
} else {
rownames(rt) <- converted_genes
}
# **检查 NaN 并替换**
rt[is.na(rt)] <- 0  # 替换 NaN 为 0
# **样本分组**
control_samples <- c("Control_1", "Control_2", "Control_3")
treatment_samples <- c("Treatment_1", "Treatment_2", "Treatment_3")
View(rt)
# **提取目标基因**
gene <- "ENSG00000080824"
if (gene %in% rownames(rt)) {
dataL <- rt[gene, control_samples, drop=F]
dataH <- rt[gene, treatment_samples, drop=F]
# 计算均值并避免 log 计算问题
meanL <- rowMeans(dataL, na.rm=TRUE)
meanH <- rowMeans(dataH, na.rm=TRUE)
meanL[meanL < 0.00001] <- 0.00001
meanH[meanH < 0.00001] <- 0.00001
# 计算 logFC
logFC <- log2(meanH) - log2(meanL)
logFC <- sort(logFC, decreasing=T)
} else {
stop(paste("错误：基因", gene, "不在数据集中，请检查基因 ID 是否正确"))
}
# 先转换基因名
gene <- "ENSG00000080824"
gene_entrez <- mapIds(
EnsDb.Hsapiens.v86,
keys = gene,
column = "ENTREZID",
keytype = "GENEID",
multiVals = "first"
)
if (!is.na(gene_entrez) && gene_entrez %in% rownames(rt)) {
dataL <- rt[gene_entrez, control_samples, drop=F]
dataH <- rt[gene_entrez, treatment_samples, drop=F]
# 计算均值并避免 log 计算问题
meanL <- rowMeans(dataL, na.rm=TRUE)
meanH <- rowMeans(dataH, na.rm=TRUE)
meanL[meanL < 0.00001] <- 0.00001
meanH[meanH < 0.00001] <- 0.00001
# 计算 logFC
logFC <- log2(meanH) - log2(meanL)
logFC <- sort(logFC, decreasing=T)
} else {
stop(paste("错误：基因", gene, "的 ENTREZID", gene_entrez, "不在数据集中，请检查基因 ID 是否正确"))
}
# **GO 富集分析**
gmt_go <- read.gmt("c5.go.v7.4.symbols.gmt")
kk_go <- GSEA(logFC, TERM2GENE=gmt_go, pvalueCutoff=1)
write.table(kkTab_go, file=paste0(gene, "_GSEA.result-GO.txt"), sep="\t", quote=F, row.names=F)
head(names(logFC))
View(rt)
View(gmt_go)
View(dataL)
View(dataH)
# 计算 logFC
logFC <- log2(meanH) - log2(meanL)
# 确保 logFC 有正确的基因 ID
names(logFC) <- rownames(rt)
if (!is.na(gene_entrez) && gene_entrez %in% rownames(rt)) {
dataL <- rt[gene_entrez, control_samples, drop=F]
dataH <- rt[gene_entrez, treatment_samples, drop=F]
}
# 计算所有基因的均值
meanL <- rowMeans(rt[, control_samples], na.rm=TRUE)
meanH <- rowMeans(rt[, treatment_samples], na.rm=TRUE)
# 避免 log 计算问题
meanL[meanL < 0.00001] <- 0.00001
meanH[meanH < 0.00001] <- 0.00001
# 计算 logFC
logFC <- log2(meanH) - log2(meanL)
# 确保 logFC 有正确的基因 ID
names(logFC) <- rownames(rt)
logFC <- sort(logFC, decreasing = TRUE)
# 计算 logFC
logFC <- log2(meanH) - log2(meanL)
# 确保 logFC 有正确的基因 ID
names(logFC) <- rownames(rt)
logFC <- sort(logFC, decreasing = TRUE)
# **GO 富集分析**
gmt_go <- read.gmt("c5.go.v7.4.symbols.gmt")
kk_go <- GSEA(logFC, TERM2GENE=gmt_go, pvalueCutoff=1)
# 加载必要的 R 包
library(limma)
library(clusterProfiler)
library(enrichplot)
library(ggplot2)
library(tidyverse)
library(EnsDb.Hsapiens.v86)
library(org.Hs.eg.db)
# 读取 RNAseq 表达数据（行是基因，列是样本）
rt <- read.table("RNAseq_data.txt", header=T, sep="\t", check.names=F, row.names=1)
# 获取基因名（ENSEMBL ID）
gene_ids <- rownames(rt)
# 去重：如果有重复的 ENSEMBL ID，仅保留第一个
rt <- rt[!duplicated(gene_ids), ]
# **转换 ENSEMBL ID 为 ENTREZID**
converted_genes <- mapIds(
EnsDb.Hsapiens.v86,
keys = gene_ids,
column = "ENTREZID",
keytype = "GENEID",
multiVals = "first"
)
# 仅保留有 ENTREZID 的行
valid_genes <- !is.na(converted_genes)
rt <- rt[valid_genes, ]
converted_genes <- converted_genes[valid_genes]
# **处理重复的 ENTREZID**
if (any(duplicated(converted_genes))) {
print("存在重复 ENTREZID，正在合并这些基因的表达数据...")
# 绑定 ENTREZID 并计算均值
rt <- cbind(ENTREZID = converted_genes, rt)
rt <- rt %>%
group_by(ENTREZID) %>%
summarise(across(everything(), mean, na.rm=TRUE))
# 设置 ENTREZID 作为行名并删除该列
rownames(rt) <- rt$ENTREZID
rt <- rt[, -1]
} else {
rownames(rt) <- converted_genes
}
# **检查 NaN 并替换**
rt[is.na(rt)] <- 0  # 替换 NaN 为 0
# **定义样本分组**
control_samples <- c("Control_1", "Control_2", "Control_3")
treatment_samples <- c("Treatment_1", "Treatment_2", "Treatment_3")
# **计算 logFC**
meanL <- rowMeans(rt[, control_samples], na.rm=TRUE)
meanH <- rowMeans(rt[, treatment_samples], na.rm=TRUE)
# 避免 log 计算问题
meanL[meanL < 0.00001] <- 0.00001
meanH[meanH < 0.00001] <- 0.00001
logFC <- log2(meanH) - log2(meanL)
# **确保 logFC 有正确的基因 ID**
names(logFC) <- rownames(rt)
logFC <- sort(logFC, decreasing = TRUE)
# **读取 GO 术语集**
gmt_go <- read.gmt("c5.go.v7.4.symbols.gmt")
# **执行 GSEA (GO)**
kk_go <- tryCatch({
GSEA(logFC, TERM2GENE=gmt_go, pvalueCutoff=1)
}, error = function(e) {
print("GO GSEA 失败！请检查数据格式")
return(NULL)
})
if (!is.null(kk_go)) {
kkTab_go <- as.data.frame(kk_go) %>% filter(pvalue < 0.05)
write.table(kkTab_go, file="GSEA_result_GO.txt", sep="\t", quote=F, row.names=F)
# **绘制 GO 富集分析图**
if (nrow(kkTab_go) >= 5) {
showTerm <- row.names(kkTab_go)[1:5]
} else {
showTerm <- row.names(kkTab_go)
}
pdf(file="GSEA-GO.pdf", width=10, height=8)
print(gseaplot2(kk_go, showTerm, base_size=8, title="GO GSEA"))
dev.off()
}
# **读取 KEGG 术语集**
gmt_kegg <- read.gmt("c2.cp.kegg.v7.4.symbols.gmt")
# **执行 GSEA (KEGG)**
kk_kegg <- tryCatch({
GSEA(logFC, TERM2GENE=gmt_kegg, pvalueCutoff=1)
}, error = function(e) {
print("KEGG GSEA 失败！请检查数据格式")
return(NULL)
})
if (!is.null(kk_kegg)) {
kkTab_kegg <- as.data.frame(kk_kegg) %>% filter(pvalue < 0.05)
write.table(kkTab_kegg, file="GSEA_result_KEGG.txt", sep="\t", quote=F, row.names=F)
# **绘制 KEGG 富集分析图**
if (nrow(kkTab_kegg) >= 5) {
showTerm <- row.names(kkTab_kegg)[1:5]
} else {
showTerm <- row.names(kkTab_kegg)
}
pdf(file="GSEA-KEGG.pdf", width=10, height=8)
print(gseaplot2(kk_kegg, showTerm, base_size=8, title="KEGG GSEA"))
dev.off()
}
print("GSEA 分析完成！")
if(nrow(kkTab)>=termNum){
showTerm=row.names(kkTab)[1:termNum]
gseaplot=gseaplot2(kk, showTerm, base_size=8, title="")
gseaplot[[1]]=gseaplot[[1]]+theme(legend.position="right",legend.direction="vertical")
pdf(file=paste0(gene,"_GSEA-KEGG.pdf"), width=10, height=8)
print(gseaplot)
dev.off()
}
# 读取 RNAseq 表达数据（行是基因，列是样本）
rt <- read.table("RNAseq_data.txt", header=T, sep="\t", check.names=F, row.names=1)
# 获取基因名（ENSEMBL ID）
gene_ids <- rownames(rt)
# **去重**
rt <- rt[!duplicated(gene_ids), ]
# **转换 ENSEMBL ID 为 ENTREZID**
converted_genes <- mapIds(
EnsDb.Hsapiens.v86,
keys = gene_ids,
column = "ENTREZID",
keytype = "GENEID",
multiVals = "first"
)
# 仅保留有 ENTREZID 的行
valid_genes <- !is.na(converted_genes)
rt <- rt[valid_genes, ]
converted_genes <- converted_genes[valid_genes]
# **处理重复 ENTREZID**
if (any(duplicated(converted_genes))) {
print("存在重复 ENTREZID，正在合并这些基因的表达数据...")
# 绑定 ENTREZID 并计算均值
rt <- cbind(ENTREZID = converted_genes, rt)
rt <- rt %>%
group_by(ENTREZID) %>%
summarise(across(everything(), mean, na.rm=TRUE))
# 设置 ENTREZID 作为行名并删除该列
rownames(rt) <- rt$ENTREZID
rt <- rt[, -1]
} else {
rownames(rt) <- converted_genes
}
# **检查 NaN 并替换**
rt[is.na(rt)] <- 0
# **定义样本分组**
control_samples <- c("Control_1", "Control_2", "Control_3")
treatment_samples <- c("Treatment_1", "Treatment_2", "Treatment_3")
# **计算 logFC**
meanL <- rowMeans(rt[, control_samples], na.rm=TRUE)
meanH <- rowMeans(rt[, treatment_samples], na.rm=TRUE)
# 避免 log 计算问题
meanL[meanL < 0.00001] <- 0.00001
meanH[meanH < 0.00001] <- 0.00001
logFC <- log2(meanH) - log2(meanL)
# **去除异常值**
logFC <- logFC[!is.na(logFC) & !is.infinite(logFC)]
# **确保 logFC 有正确的基因 ID**
names(logFC) <- rownames(rt)
logFC <- sort(logFC, decreasing = TRUE)
# **读取 GO 术语集**
gmt_go <- read.gmt("c5.go.v7.4.symbols.gmt")
# **执行 GSEA (GO)**
kk_go <- tryCatch({
GSEA(logFC, TERM2GENE=gmt_go, pvalueCutoff=1)
}, error = function(e) {
print("GO GSEA 失败！请检查数据格式")
return(NULL)
})
# **转换 gmt_go 的 SYMBOL 为 ENTREZID**
gmt_go$ENTREZID <- mapIds(
org.Hs.eg.db,
keys = gmt_go$gene,
column = "ENTREZID",
keytype = "SYMBOL",
multiVals = "first"
)
# 移除无法映射的基因
gmt_go <- gmt_go[!is.na(gmt_go$ENTREZID), ]
# 重新命名列以匹配 `TERM2GENE` 格式
gmt_go <- gmt_go[, c("term", "ENTREZID")]
colnames(gmt_go) <- c("TERM", "GENE")
# **执行 GSEA (GO)**
kk_go <- tryCatch({
GSEA(logFC, TERM2GENE=gmt_go, pvalueCutoff=1)
}, error = function(e) {
print("GO GSEA 失败！请检查数据格式")
return(NULL)
})
if (!is.null(kk_go)) {
kkTab_go <- as.data.frame(kk_go) %>% filter(pvalue < 0.05)
write.table(kkTab_go, file="GSEA_result_GO.txt", sep="\t", quote=F, row.names=F)
# **绘制 GO 富集分析图**
if (nrow(kkTab_go) >= 5) {
showTerm <- row.names(kkTab_go)[1:5]
} else {
showTerm <- row.names(kkTab_go)
}
pdf(file="GSEA-GO.pdf", width=10, height=8)
print(gseaplot2(kk_go, showTerm, base_size=8, title="GO GSEA"))
dev.off()
}
# 确保 GSEA 结果不是 NULL
if (!is.null(kk_go)) {
# 将 GSEA 结果转换为数据框，并正确调用 `filter()`
kkTab_go <- as.data.frame(kk_go) %>%
dplyr::filter(p.adjust < 0.05)  # GSEA 结果通常用 `p.adjust` 而非 `pvalue`
# 仅当有显著富集结果时才保存和绘图
if (nrow(kkTab_go) > 0) {
write.table(kkTab_go, file="GSEA_result_GO.txt", sep="\t", quote=F, row.names=F)
# **绘制 GO 富集分析图**
showTerm <- kkTab_go$ID[1:min(5, nrow(kkTab_go))]  # 取前 5 个显著通路
pdf(file="GSEA-GO.pdf", width=10, height=8)
print(gseaplot2(kk_go, showTerm, base_size=8, title="GO GSEA"))
dev.off()
} else {
print("GO GSEA 结果没有显著富集的通路")
}
}
# **读取 KEGG 术语集**
gmt_kegg <- read.gmt("c2.cp.kegg.v7.4.symbols.gmt")
# **转换 gmt_kegg 的 SYMBOL 为 ENTREZID**
gmt_kegg$ENTREZID <- mapIds(
org.Hs.eg.db,
keys = gmt_kegg$gene,
column = "ENTREZID",
keytype = "SYMBOL",
multiVals = "first"
)
# 移除无法映射的基因
gmt_kegg <- gmt_kegg[!is.na(gmt_kegg$ENTREZID), ]
# 重新命名列以匹配 `TERM2GENE` 格式
gmt_kegg <- gmt_kegg[, c("term", "ENTREZID")]
colnames(gmt_kegg) <- c("TERM", "GENE")
# **执行 GSEA (KEGG)**
kk_kegg <- tryCatch({
GSEA(logFC, TERM2GENE=gmt_kegg, pvalueCutoff=1)
}, error = function(e) {
print("KEGG GSEA 失败！请检查数据格式")
return(NULL)
})
if (!is.null(kk_kegg)) {
kkTab_kegg <- as.data.frame(kk_kegg) %>% filter(pvalue < 0.05)
write.table(kkTab_kegg, file="GSEA_result_KEGG.txt", sep="\t", quote=F, row.names=F)
# **绘制 KEGG 富集分析图**
if (nrow(kkTab_kegg) >= 5) {
showTerm <- row.names(kkTab_kegg)[1:5]
} else {
showTerm <- row.names(kkTab_kegg)
}
pdf(file="GSEA-KEGG.pdf", width=10, height=8)
print(gseaplot2(kk_kegg, showTerm, base_size=8, title="KEGG GSEA"))
dev.off()
}
View(kk_kegg)
# 确保 GSEA 结果不是 NULL
if (!is.null(kk_kegg)) {
# 将 GSEA 结果转换为数据框，并正确调用 `dplyr::filter()`
kkTab_kegg <- as.data.frame(kk_kegg) %>%
dplyr::filter(p.adjust < 0.05)  # 使用调整后的 P 值（p.adjust）
# 仅当有显著富集结果时才保存和绘图
if (nrow(kkTab_kegg) > 0) {
write.table(kkTab_kegg, file="GSEA_result_KEGG.txt", sep="\t", quote=F, row.names=F)
# **绘制 KEGG 富集分析图**
showTerm <- kkTab_kegg$ID[1:min(5, nrow(kkTab_kegg))]  # 取前 5 个显著通路
pdf(file="GSEA-KEGG.pdf", width=10, height=8)
print(gseaplot2(kk_kegg, showTerm, base_size=8, title="KEGG GSEA"))
dev.off()
} else {
print("KEGG GSEA 结果没有显著富集的通路")
}
}
# **读取 KEGG 术语集**
gmt_kegg <- read.gmt("c2.cp.kegg.v7.4.symbols.gmt")
# **转换 gmt_kegg 的 SYMBOL 为 ENTREZID**
gmt_kegg$ENTREZID <- mapIds(
org.Hs.eg.db,
keys = gmt_kegg$gene,
column = "ENTREZID",
keytype = "SYMBOL",
multiVals = "first"
)
# 移除无法映射的基因
gmt_kegg <- gmt_kegg[!is.na(gmt_kegg$ENTREZID), ]
# 重新命名列以匹配 `TERM2GENE` 格式
gmt_kegg <- gmt_kegg[, c("term", "ENTREZID")]
colnames(gmt_kegg) <- c("TERM", "GENE")
# **执行 GSEA (KEGG)**
kk_kegg <- tryCatch({
GSEA(logFC, TERM2GENE=gmt_kegg, pvalueCutoff=1)
}, error = function(e) {
print("KEGG GSEA 失败！请检查数据格式")
return(NULL)
})
if (!is.null(kk_kegg)) {
kkTab_kegg <- as.data.frame(kk_kegg) %>% dplyr::filter(pvalue < 0.05)
write.table(kkTab_kegg, file="GSEA_result_KEGG.txt", sep="\t", quote=F, row.names=F)
# **绘制 KEGG 富集分析图**
if (nrow(kkTab_kegg) >= 5) {
showTerm <- row.names(kkTab_kegg)[1:5]
} else {
showTerm <- row.names(kkTab_kegg)
}
pdf(file="GSEA-KEGG.pdf", width=10, height=8)
print(gseaplot2(kk_kegg, showTerm, base_size=8, title="KEGG GSEA"))
dev.off()
}
# **执行 GSEA (GO)**
kk_go <- tryCatch({
GSEA(logFC, TERM2GENE=gmt_go, pvalueCutoff=1)
}, error = function(e) {
print("GO GSEA 失败！请检查数据格式")
return(NULL)
})
if (!is.null(kk_go)) {
kkTab_go <- as.data.frame(kk_go) %>% dplyr::filter(pvalue < 0.05)
write.table(kkTab_go, file="GSEA_result_GO.txt", sep="\t", quote=F, row.names=F)
# **绘制 GO 富集分析图**
if (nrow(kkTab_go) >= 5) {
showTerm <- row.names(kkTab_go)[1:5]
} else {
showTerm <- row.names(kkTab_go)
}
pdf(file="GSEA-GO.pdf", width=10, height=8)
print(gseaplot2(kk_go, showTerm, base_size=8, title="GO GSEA"))
dev.off()
}
View(kk_kegg)
kk_kegg@result[["ID"]]
View(gmt_go)
View(kk_go)
kk_go@result[["ID"]]
kk_go@result[["ID"]]
kk_go@result[["ID"]]
# **绘制 GO 富集分析图**
if (nrow(kkTab_go) >= 5) {
showTerm <- row.names(kkTab_go)[35:39]
} else {
showTerm <- row.names(kkTab_go)
}
pdf(file="GSEA-GO35-39.pdf", width=10, height=8)
print(gseaplot2(kk_go, showTerm, base_size=8, title="GO GSEA"))
dev.off()
